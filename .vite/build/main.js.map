{"version":3,"file":"main.js","sources":["../../node_modules/uuid/dist-node/stringify.js","../../node_modules/uuid/dist-node/rng.js","../../node_modules/uuid/dist-node/native.js","../../node_modules/uuid/dist-node/v4.js","../../src/main/rules/types.ts","../../src/main/rules/parser.ts","../../src/main/rules/matcher.ts","../../src/main/rules/context.ts","../../src/main/rules/conflicts.ts","../../src/main/scanner/index.ts","../../src/main/scanner/listChildren.ts","../../src/main/scanner/explain.ts","../../src/main/ipc.ts","../../src/main/index.ts"],"sourcesContent":["import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n","import { randomFillSync } from 'node:crypto';\nconst rnds8Pool = new Uint8Array(256);\nlet poolPtr = rnds8Pool.length;\nexport default function rng() {\n    if (poolPtr > rnds8Pool.length - 16) {\n        randomFillSync(rnds8Pool);\n        poolPtr = 0;\n    }\n    return rnds8Pool.slice(poolPtr, (poolPtr += 16));\n}\n","import { randomUUID } from 'node:crypto';\nexport default { randomUUID };\n","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction _v4(options, buf, offset) {\n    options = options || {};\n    const rnds = options.random ?? options.rng?.() ?? rng();\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(rnds);\n}\nfunction v4(options, buf, offset) {\n    if (native.randomUUID && !buf && !options) {\n        return native.randomUUID();\n    }\n    return _v4(options, buf, offset);\n}\nexport default v4;\n","/**\r\n * Core types for the Smart Copy Utility rule engine.\r\n *\r\n * These types define the data model for rule files, patterns, contexts,\r\n * and tree nodes as described in the design document.\r\n */\r\n\r\n// ── Rule File Types ──────────────────────────────────────────────────\r\n\r\n/** The type of rule file found in a directory. */\r\nexport enum RuleType {\r\n  IGNORE_FILE = 'IGNORE_FILE',\r\n  INCLUDE_FILE = 'INCLUDE_FILE',\r\n}\r\n\r\n/** A single pattern line parsed from a rule file. */\r\nexport interface PatternEntry {\r\n  /** The raw pattern text (e.g., \"node_modules/\", \"*.log\", \"src/main.ts\") */\r\n  patternText: string;\r\n  /** 1-based line number in the rule file */\r\n  lineNumber: number;\r\n  /** Absolute path to the rule file this pattern came from */\r\n  ruleFilePath: string;\r\n}\r\n\r\n/** A parsed rule file record. */\r\nexport interface RuleFileRecord {\r\n  /** Absolute path to the rule file */\r\n  path: string;\r\n  /** Whether this is a .copyignore or .copyinclude file */\r\n  type: RuleType;\r\n  /** Parsed pattern entries (comments and blanks stripped) */\r\n  lines: PatternEntry[];\r\n}\r\n\r\n// ── Rule File Constants ──────────────────────────────────────────────\r\n\r\n/** Recognized rule file names (case-insensitive matching on Windows). */\r\nexport const COPYIGNORE_NAME = '.copyignore';\r\nexport const COPYINCLUDE_NAME = '.copyinclude';\r\n\r\n// ── Mode & Context ───────────────────────────────────────────────────\r\n\r\n/** The active filtering mode at a given directory path. */\r\nexport enum RuleMode {\r\n  /** No rule files encountered on the path from root to here. */\r\n  NONE = 'NONE',\r\n  /** Blacklist mode: exclude anything matching patterns. */\r\n  IGNORE = 'IGNORE',\r\n  /** Whitelist mode: include only things matching patterns. */\r\n  INCLUDE = 'INCLUDE',\r\n}\r\n\r\n/** The evaluated context at a directory during traversal. */\r\nexport interface RuleContext {\r\n  /** Current filtering mode */\r\n  mode: RuleMode;\r\n  /** Effective pattern entries (stacked or reset) */\r\n  patterns: PatternEntry[];\r\n  /** Chain of rule file paths contributing to this context (for explain) */\r\n  ruleChain: string[];\r\n}\r\n\r\n// ── Tree Node ────────────────────────────────────────────────────────\r\n\r\n/** Possible states for a tree node in the preview. */\r\nexport enum NodeState {\r\n  INCLUDED = 'INCLUDED',\r\n  EXCLUDED = 'EXCLUDED',\r\n  CONFLICT = 'CONFLICT',\r\n  UNKNOWN = 'UNKNOWN',\r\n}\r\n\r\n/** A node in the preview tree. */\r\nexport interface TreeNode {\r\n  /** Absolute path */\r\n  path: string;\r\n  /** Display name (basename) */\r\n  name: string;\r\n  /** True if this is a directory */\r\n  isDir: boolean;\r\n  /** Current include/exclude state */\r\n  state: NodeState;\r\n  /** Whether this directory has children (always false for files) */\r\n  hasChildren: boolean;\r\n  /** The active rule mode at this path */\r\n  modeAtPath: RuleMode;\r\n}\r\n\r\n// ── Match Result ─────────────────────────────────────────────────────\r\n\r\n/** Result of matching a path against a set of patterns. */\r\nexport interface MatchResult {\r\n  /** Whether at least one pattern matched */\r\n  matched: boolean;\r\n  /** All patterns that matched (for explainability) */\r\n  matchingPatterns: PatternEntry[];\r\n}\r\n","/**\r\n * Rule file parser — reads .copyignore and .copyinclude files\r\n * and produces structured RuleFileRecord objects.\r\n *\r\n * Handles:\r\n * - Blank line skipping\r\n * - Comment lines (starting with #)\r\n * - Case-insensitive file name detection\r\n * - Graceful handling of missing/unreadable files\r\n */\r\n\r\nimport fs from 'fs/promises';\r\nimport path from 'path';\r\nimport {\r\n  RuleType,\r\n  RuleFileRecord,\r\n  PatternEntry,\r\n  COPYIGNORE_NAME,\r\n  COPYINCLUDE_NAME,\r\n} from './types';\r\n\r\n/**\r\n * Determines the rule type based on the file name (case-insensitive).\r\n * Returns null if the file name is not a recognized rule file.\r\n */\r\nexport function getRuleTypeFromFileName(fileName: string): RuleType | null {\r\n  const lower = fileName.toLowerCase();\r\n  if (lower === COPYIGNORE_NAME) return RuleType.IGNORE_FILE;\r\n  if (lower === COPYINCLUDE_NAME) return RuleType.INCLUDE_FILE;\r\n  return null;\r\n}\r\n\r\n/**\r\n * Parses the raw content of a rule file into PatternEntry objects.\r\n * Skips blank lines and comment lines (starting with #).\r\n */\r\nexport function parseRuleContent(\r\n  content: string,\r\n  ruleFilePath: string\r\n): PatternEntry[] {\r\n  const lines = content.split(/\\r?\\n/);\r\n  const patterns: PatternEntry[] = [];\r\n\r\n  for (let i = 0; i < lines.length; i++) {\r\n    const line = lines[i].trim();\r\n\r\n    // Skip blank lines\r\n    if (line === '') continue;\r\n\r\n    // Skip comment lines\r\n    if (line.startsWith('#')) continue;\r\n\r\n    patterns.push({\r\n      patternText: line,\r\n      lineNumber: i + 1, // 1-based\r\n      ruleFilePath,\r\n    });\r\n  }\r\n\r\n  return patterns;\r\n}\r\n\r\n/**\r\n * Reads and parses a rule file at the given absolute path.\r\n * Returns null if the file doesn't exist or can't be read.\r\n */\r\nexport async function parseRuleFile(\r\n  filePath: string\r\n): Promise<RuleFileRecord | null> {\r\n  const fileName = path.basename(filePath);\r\n  const ruleType = getRuleTypeFromFileName(fileName);\r\n\r\n  if (ruleType === null) {\r\n    return null;\r\n  }\r\n\r\n  try {\r\n    const content = await fs.readFile(filePath, 'utf-8');\r\n    const patterns = parseRuleContent(content, filePath);\r\n\r\n    return {\r\n      path: filePath,\r\n      type: ruleType,\r\n      lines: patterns,\r\n    };\r\n  } catch {\r\n    // File doesn't exist or can't be read — return null gracefully\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Scans a directory for rule files (.copyignore / .copyinclude).\r\n * Returns an array of found rule file records (0, 1, or 2 if conflict).\r\n * File name matching is case-insensitive.\r\n */\r\nexport async function findRuleFilesInDir(\r\n  dirPath: string\r\n): Promise<RuleFileRecord[]> {\r\n  const results: RuleFileRecord[] = [];\r\n\r\n  try {\r\n    const entries = await fs.readdir(dirPath);\r\n\r\n    for (const entry of entries) {\r\n      const ruleType = getRuleTypeFromFileName(entry);\r\n      if (ruleType !== null) {\r\n        const fullPath = path.join(dirPath, entry);\r\n        const record = await parseRuleFile(fullPath);\r\n        if (record) {\r\n          results.push(record);\r\n        }\r\n      }\r\n    }\r\n  } catch {\r\n    // Directory unreadable — return empty\r\n  }\r\n\r\n  return results;\r\n}\r\n","/**\r\n * Pattern matching engine — evaluates whether a given file or directory path\r\n * matches a set of patterns from rule files.\r\n *\r\n * Supported pattern types:\r\n * - `name/`       — matches directories with that name at any depth\r\n * - `*.ext`       — matches files by extension (simple glob)\r\n * - `foo/bar.txt` — matches relative path segments from rule file directory\r\n *\r\n * All matching is case-insensitive on Windows.\r\n * Returns all matching patterns (not just first) for explainability.\r\n */\r\n\r\nimport path from 'path';\r\nimport { PatternEntry, MatchResult } from './types';\r\n\r\n/**\r\n * Normalizes a path to use backslashes and lowercase for consistent matching.\r\n */\r\nfunction normalizePath(p: string): string {\r\n  return p.replace(/\\//g, '\\\\').toLowerCase();\r\n}\r\n\r\n/**\r\n * Classifies a pattern into one of three types.\r\n */\r\nfunction classifyPattern(patternText: string): 'dir' | 'glob' | 'relative' {\r\n  // Directory name pattern: ends with /\r\n  if (patternText.endsWith('/')) return 'dir';\r\n\r\n  // Glob pattern: starts with * or contains * in the filename portion\r\n  // e.g., *.log, *.txt, *.min.js\r\n  if (patternText.startsWith('*') || patternText.startsWith('?')) return 'glob';\r\n\r\n  // Check if it's a simple glob like *.ext (no path separators)\r\n  const hasPathSep = patternText.includes('/') || patternText.includes('\\\\');\r\n  if (!hasPathSep && patternText.includes('*')) return 'glob';\r\n\r\n  // Relative path pattern\r\n  if (hasPathSep) return 'relative';\r\n\r\n  // Simple filename or glob (e.g., \"*.log\" or \"README.md\")\r\n  if (patternText.includes('*') || patternText.includes('?')) return 'glob';\r\n\r\n  // Exact filename match — treat as relative path\r\n  return 'relative';\r\n}\r\n\r\n/**\r\n * Tests if a simple glob pattern (like *.ext) matches a file name.\r\n * Supports:\r\n * - `*` matches any sequence of characters (no path separator)\r\n * - `?` matches any single character\r\n */\r\nfunction matchGlob(pattern: string, fileName: string): boolean {\r\n  // Convert glob to regex\r\n  let regex = '^';\r\n  for (let i = 0; i < pattern.length; i++) {\r\n    const c = pattern[i];\r\n    switch (c) {\r\n      case '*':\r\n        regex += '[^\\\\\\\\]*';\r\n        break;\r\n      case '?':\r\n        regex += '[^\\\\\\\\]';\r\n        break;\r\n      case '.':\r\n        regex += '\\\\.';\r\n        break;\r\n      default:\r\n        regex += c;\r\n    }\r\n  }\r\n  regex += '$';\r\n\r\n  return new RegExp(regex, 'i').test(fileName);\r\n}\r\n\r\n/**\r\n * Matches a single pattern against a target path.\r\n *\r\n * @param patternText - The pattern text to match\r\n * @param targetPath - The absolute path of the file/directory being tested\r\n * @param isDir - Whether the target is a directory\r\n * @param ruleFileDir - The directory containing the rule file (for relative path resolution)\r\n * @returns true if the pattern matches\r\n */\r\nexport function matchPattern(\r\n  patternText: string,\r\n  targetPath: string,\r\n  isDir: boolean,\r\n  ruleFileDir: string\r\n): boolean {\r\n  const kind = classifyPattern(patternText);\r\n  const normalizedTarget = normalizePath(targetPath);\r\n\r\n  switch (kind) {\r\n    case 'dir': {\r\n      // Directory name pattern: \"name/\" matches any directory with that name\r\n      // at any depth beneath the rule file directory.\r\n      if (!isDir) {\r\n        // Also match if the target file is *inside* a directory with that name\r\n        const dirName = normalizePath(patternText.slice(0, -1)); // remove trailing /\r\n        const segments = normalizedTarget.split('\\\\');\r\n        const ruleSegments = normalizePath(ruleFileDir).split('\\\\');\r\n\r\n        // Only match segments beneath the rule file directory\r\n        for (let i = ruleSegments.length; i < segments.length; i++) {\r\n          if (segments[i] === dirName) return true;\r\n        }\r\n        return false;\r\n      }\r\n\r\n      // For directories: check if the directory name matches\r\n      const dirName = normalizePath(patternText.slice(0, -1));\r\n      const targetName = path.basename(normalizedTarget);\r\n\r\n      if (targetName === dirName) {\r\n        // Verify target is at or beneath rule file directory\r\n        const normalizedRuleDir = normalizePath(ruleFileDir);\r\n        return normalizedTarget.startsWith(normalizedRuleDir);\r\n      }\r\n      return false;\r\n    }\r\n\r\n    case 'glob': {\r\n      // Glob pattern: match against the file/directory name only\r\n      const targetName = path.basename(targetPath);\r\n      return matchGlob(patternText, targetName);\r\n    }\r\n\r\n    case 'relative': {\r\n      // Relative path: compare against relative path from rule file directory\r\n      const normalizedRuleDir = normalizePath(ruleFileDir);\r\n      const normalizedPattern = normalizePath(patternText);\r\n\r\n      // Build the expected absolute path\r\n      const expectedPath = normalizedRuleDir + '\\\\' + normalizedPattern;\r\n\r\n      // Exact match\r\n      if (normalizedTarget === expectedPath) return true;\r\n\r\n      // Also check as a prefix (for dirs specified without trailing slash)\r\n      if (!patternText.includes('*') && !patternText.includes('?')) {\r\n        // Check if target is under the specified relative path\r\n        if (normalizedTarget.startsWith(expectedPath + '\\\\')) return true;\r\n      }\r\n\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Matches a target path against an array of patterns.\r\n * Returns all matching patterns for explainability.\r\n *\r\n * @param patterns - Array of pattern entries to test\r\n * @param targetPath - Absolute path of the file/directory being tested\r\n * @param isDir - Whether the target is a directory\r\n * @param ruleFileDir - The directory containing the rule file\r\n * @returns MatchResult with `matched` boolean and `matchingPatterns` array\r\n */\r\nexport function matchPatterns(\r\n  patterns: PatternEntry[],\r\n  targetPath: string,\r\n  isDir: boolean,\r\n  ruleFileDir: string\r\n): MatchResult {\r\n  const matchingPatterns: PatternEntry[] = [];\r\n\r\n  for (const pattern of patterns) {\r\n    // Each pattern may come from a different rule file, so resolve the\r\n    // rule file directory per-pattern.\r\n    const patternRuleDir = path.dirname(pattern.ruleFilePath);\r\n    if (matchPattern(pattern.patternText, targetPath, isDir, patternRuleDir)) {\r\n      matchingPatterns.push(pattern);\r\n    }\r\n  }\r\n\r\n  return {\r\n    matched: matchingPatterns.length > 0,\r\n    matchingPatterns,\r\n  };\r\n}\r\n","/**\r\n * Context management and mode traversal system.\r\n *\r\n * Maintains a stack-based context during directory tree traversal.\r\n * Implements:\r\n * - NONE → IGNORE/INCLUDE: reset to new mode's patterns\r\n * - Same-mode stacking: append patterns from child rule file\r\n * - Mode switch reset: replace patterns entirely on mode change\r\n * - Push/pop for sibling isolation (no leakage)\r\n * - Memoization of computed contexts by directory path\r\n */\r\n\r\nimport path from 'path';\r\nimport { RuleMode, RuleContext, RuleType, RuleFileRecord } from './types';\r\nimport { findRuleFilesInDir } from './parser';\r\n\r\n/** Creates the initial root context (NONE mode, no patterns). */\r\nexport function createRootContext(): RuleContext {\r\n  return {\r\n    mode: RuleMode.NONE,\r\n    patterns: [],\r\n    ruleChain: [],\r\n  };\r\n}\r\n\r\n/**\r\n * Derives a new context for a child directory based on the parent context\r\n * and any rule files found in the child directory.\r\n *\r\n * Stacking/reset rules:\r\n * - If child has .copyignore:\r\n *   - Parent IGNORE → stack (parent patterns + child patterns)\r\n *   - Parent INCLUDE or NONE → reset (child patterns only)\r\n *   - Mode becomes IGNORE\r\n * - If child has .copyinclude:\r\n *   - Parent INCLUDE → stack (parent patterns + child patterns)\r\n *   - Parent IGNORE or NONE → reset (child patterns only)\r\n *   - Mode becomes INCLUDE\r\n * - If child has no rule file:\r\n *   - Inherit parent context unchanged\r\n *\r\n * @param parentContext - The parent directory's context\r\n * @param ruleFiles - Rule files found in the child directory (0 or 1; 2 = conflict handled elsewhere)\r\n * @returns The new context for the child directory\r\n */\r\nexport function deriveChildContext(\r\n  parentContext: RuleContext,\r\n  ruleFiles: RuleFileRecord[]\r\n): RuleContext {\r\n  // No rule files → inherit parent unchanged\r\n  if (ruleFiles.length === 0) {\r\n    return { ...parentContext };\r\n  }\r\n\r\n  // Use the first non-conflict rule file (conflicts are detected separately)\r\n  // If there are 2 files (conflict), we still derive from the first one found,\r\n  // but conflict detection will block operations.\r\n  const ruleFile = ruleFiles[0];\r\n\r\n  if (ruleFile.type === RuleType.IGNORE_FILE) {\r\n    // .copyignore found\r\n    if (parentContext.mode === RuleMode.IGNORE) {\r\n      // Stack: parent patterns + new patterns\r\n      return {\r\n        mode: RuleMode.IGNORE,\r\n        patterns: [...parentContext.patterns, ...ruleFile.lines],\r\n        ruleChain: [...parentContext.ruleChain, ruleFile.path],\r\n      };\r\n    } else {\r\n      // Reset: new patterns only (from INCLUDE or NONE)\r\n      return {\r\n        mode: RuleMode.IGNORE,\r\n        patterns: [...ruleFile.lines],\r\n        ruleChain: [ruleFile.path],\r\n      };\r\n    }\r\n  } else {\r\n    // .copyinclude found\r\n    if (parentContext.mode === RuleMode.INCLUDE) {\r\n      // Stack: parent patterns + new patterns\r\n      return {\r\n        mode: RuleMode.INCLUDE,\r\n        patterns: [...parentContext.patterns, ...ruleFile.lines],\r\n        ruleChain: [...parentContext.ruleChain, ruleFile.path],\r\n      };\r\n    } else {\r\n      // Reset: new patterns only (from IGNORE or NONE)\r\n      return {\r\n        mode: RuleMode.INCLUDE,\r\n        patterns: [...ruleFile.lines],\r\n        ruleChain: [ruleFile.path],\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * ContextTraverser manages context state during filesystem traversal.\r\n * Uses a stack to ensure sibling directories don't leak context.\r\n * Memoizes computed contexts by directory path.\r\n */\r\nexport class ContextTraverser {\r\n  private contextStack: RuleContext[] = [];\r\n  private contextCache: Map<string, RuleContext> = new Map();\r\n\r\n  constructor() {\r\n    // Start with root context on the stack\r\n    this.contextStack.push(createRootContext());\r\n  }\r\n\r\n  /** Returns the current (top of stack) context. */\r\n  currentContext(): RuleContext {\r\n    return this.contextStack[this.contextStack.length - 1];\r\n  }\r\n\r\n  /**\r\n   * Enter a child directory. Computes or retrieves the context for this\r\n   * directory, pushes it onto the stack.\r\n   *\r\n   * @param dirPath - Absolute path of the directory being entered\r\n   * @param ruleFiles - Rule files found in this directory\r\n   * @returns The computed context for this directory\r\n   */\r\n  enterDirectory(dirPath: string, ruleFiles: RuleFileRecord[]): RuleContext {\r\n    // Check cache first\r\n    const cached = this.contextCache.get(dirPath);\r\n    if (cached) {\r\n      this.contextStack.push(cached);\r\n      return cached;\r\n    }\r\n\r\n    const parentContext = this.currentContext();\r\n    const childContext = deriveChildContext(parentContext, ruleFiles);\r\n\r\n    // Cache and push\r\n    this.contextCache.set(dirPath, childContext);\r\n    this.contextStack.push(childContext);\r\n\r\n    return childContext;\r\n  }\r\n\r\n  /**\r\n   * Leave the current directory. Pops the context stack, reverting to\r\n   * the parent's context. Ensures no sibling leakage.\r\n   */\r\n  leaveDirectory(): void {\r\n    if (this.contextStack.length > 1) {\r\n      this.contextStack.pop();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Compute the context for a given directory path without modifying the stack.\r\n   * Useful for lazy evaluation of individual nodes.\r\n   *\r\n   * @param dirPath - Absolute path\r\n   * @param ruleFiles - Rule files in this directory\r\n   * @param parentContext - The parent directory's context\r\n   * @returns The context for this directory\r\n   */\r\n  computeContext(\r\n    dirPath: string,\r\n    ruleFiles: RuleFileRecord[],\r\n    parentContext: RuleContext\r\n  ): RuleContext {\r\n    const cached = this.contextCache.get(dirPath);\r\n    if (cached) return cached;\r\n\r\n    const context = deriveChildContext(parentContext, ruleFiles);\r\n    this.contextCache.set(dirPath, context);\r\n    return context;\r\n  }\r\n\r\n  /** Get a cached context for a directory path, if available. */\r\n  getCachedContext(dirPath: string): RuleContext | undefined {\r\n    return this.contextCache.get(dirPath);\r\n  }\r\n\r\n  /** Reset the traverser to initial state. */\r\n  reset(): void {\r\n    this.contextStack = [createRootContext()];\r\n    this.contextCache.clear();\r\n  }\r\n}\r\n\r\n/**\r\n * Convenience function: computes the context for a directory given its\r\n * parent context and the directory contents. Useful for testing and\r\n * one-off evaluations.\r\n */\r\nexport async function computeContextForDir(\r\n  dirPath: string,\r\n  parentContext: RuleContext\r\n): Promise<RuleContext> {\r\n  const ruleFiles = await findRuleFilesInDir(dirPath);\r\n  return deriveChildContext(parentContext, ruleFiles);\r\n}\r\n","/**\r\n * Conflict detection — finds directories that contain both\r\n * .copyignore and .copyinclude files (fatal conflicts).\r\n *\r\n * Scans the entire tree and collects ALL conflicts (does not stop at first).\r\n */\r\n\r\nimport fs from 'fs/promises';\r\nimport path from 'path';\r\nimport { COPYIGNORE_NAME, COPYINCLUDE_NAME } from './types';\r\n\r\n/**\r\n * Checks if a single directory contains both .copyignore and .copyinclude\r\n * (case-insensitive file name matching).\r\n *\r\n * @param dirPath - Absolute path to the directory\r\n * @returns true if both rule files are present (conflict)\r\n */\r\nexport async function hasConflict(dirPath: string): Promise<boolean> {\r\n  try {\r\n    const entries = await fs.readdir(dirPath);\r\n    const lowerEntries = entries.map((e) => e.toLowerCase());\r\n    return (\r\n      lowerEntries.includes(COPYIGNORE_NAME) &&\r\n      lowerEntries.includes(COPYINCLUDE_NAME)\r\n    );\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Recursively scans a directory tree and collects all directories\r\n * that contain both .copyignore and .copyinclude files.\r\n *\r\n * Collects ALL conflicts across the entire tree (does not stop at first).\r\n *\r\n * @param rootPath - Absolute path to the root directory to scan\r\n * @returns Array of absolute directory paths that have conflicts\r\n */\r\nexport async function detectConflicts(rootPath: string): Promise<string[]> {\r\n  const conflicts: string[] = [];\r\n\r\n  async function walk(dirPath: string): Promise<void> {\r\n    // Check this directory for conflict\r\n    try {\r\n      const entries = await fs.readdir(dirPath, { withFileTypes: true });\r\n      const lowerNames = entries.map((e) => e.name.toLowerCase());\r\n\r\n      if (\r\n        lowerNames.includes(COPYIGNORE_NAME) &&\r\n        lowerNames.includes(COPYINCLUDE_NAME)\r\n      ) {\r\n        conflicts.push(dirPath);\r\n      }\r\n\r\n      // Recurse into subdirectories\r\n      for (const entry of entries) {\r\n        if (entry.isDirectory()) {\r\n          await walk(path.join(dirPath, entry.name));\r\n        }\r\n      }\r\n    } catch {\r\n      // Skip unreadable directories\r\n    }\r\n  }\r\n\r\n  await walk(rootPath);\r\n  return conflicts;\r\n}\r\n","/**\r\n * Filesystem scanning pipeline.\r\n *\r\n * Walks the source directory tree, discovers all rule files, detects conflicts,\r\n * and builds a cached scan result for subsequent lazy tree operations.\r\n */\r\n\r\nimport fs from 'fs/promises';\r\nimport path from 'path';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport {\r\n  TreeNode,\r\n  NodeState,\r\n  RuleMode,\r\n  RuleFileRecord,\r\n  RuleContext,\r\n} from '../rules/types';\r\nimport {\r\n  findRuleFilesInDir,\r\n  detectConflicts,\r\n  createRootContext,\r\n  deriveChildContext,\r\n} from '../rules';\r\nimport { ScanResult, ScanStats, ScanArgs, ScanResponse } from './types';\r\n\r\n// Global cache of scan results keyed by scanId\r\nconst scanCache = new Map<string, ScanResult>();\r\n\r\n/**\r\n * Get a cached scan result by scanId.\r\n */\r\nexport function getCachedScan(scanId: string): ScanResult | undefined {\r\n  return scanCache.get(scanId);\r\n}\r\n\r\n/**\r\n * Main scan function. Walks the source directory tree, discovers all rule files,\r\n * detects conflicts, and returns a scan result with a root node and statistics.\r\n *\r\n * @param args - Source, destination, and rootOnly flag\r\n * @returns ScanResponse with scanId, conflicts, rootNode, and stats\r\n */\r\nexport async function scan(args: ScanArgs): Promise<ScanResponse> {\r\n  const { source, dest, rootOnly } = args;\r\n  const scanId = uuidv4();\r\n\r\n  // Initialize stats\r\n  const stats: ScanStats = {\r\n    directoriesScanned: 0,\r\n    ruleFilesFound: 0,\r\n    conflictsFound: 0,\r\n  };\r\n\r\n  // Detect conflicts across the entire tree\r\n  const conflicts = await detectConflicts(source);\r\n  stats.conflictsFound = conflicts.length;\r\n\r\n  // Build rule file index by directory path\r\n  const ruleFilesByDir = new Map<string, RuleFileRecord[]>();\r\n  const contextCache = new Map<string, RuleContext>();\r\n\r\n  // Walk the tree and discover all rule files\r\n  await walkAndIndex(source, ruleFilesByDir, stats, rootOnly);\r\n\r\n  // Build the root node\r\n  const rootNode = await buildRootNode(\r\n    source,\r\n    ruleFilesByDir,\r\n    contextCache,\r\n    rootOnly\r\n  );\r\n\r\n  // Cache the scan result\r\n  const scanResult: ScanResult = {\r\n    scanId,\r\n    sourceRoot: source,\r\n    destRoot: dest,\r\n    rootOnly,\r\n    conflicts,\r\n    rootNode,\r\n    stats,\r\n    ruleFilesByDir,\r\n    contextCache,\r\n  };\r\n\r\n  scanCache.set(scanId, scanResult);\r\n\r\n  // Return response\r\n  return {\r\n    scanId,\r\n    conflicts,\r\n    rootNode,\r\n    stats,\r\n  };\r\n}\r\n\r\n/**\r\n * Walks the directory tree and indexes all rule files by directory path.\r\n */\r\nasync function walkAndIndex(\r\n  dirPath: string,\r\n  ruleFilesByDir: Map<string, RuleFileRecord[]>,\r\n  stats: ScanStats,\r\n  rootOnly: boolean,\r\n  depth: number = 0\r\n): Promise<void> {\r\n  stats.directoriesScanned++;\r\n\r\n  // Find rule files in this directory (only at root if rootOnly is true)\r\n  if (depth === 0 || !rootOnly) {\r\n    const ruleFiles = await findRuleFilesInDir(dirPath);\r\n    if (ruleFiles.length > 0) {\r\n      ruleFilesByDir.set(dirPath, ruleFiles);\r\n      stats.ruleFilesFound += ruleFiles.length;\r\n    }\r\n  }\r\n\r\n  // Recurse into subdirectories\r\n  try {\r\n    const entries = await fs.readdir(dirPath, { withFileTypes: true });\r\n    for (const entry of entries) {\r\n      if (entry.isDirectory()) {\r\n        const childPath = path.join(dirPath, entry.name);\r\n        await walkAndIndex(childPath, ruleFilesByDir, stats, rootOnly, depth + 1);\r\n      }\r\n    }\r\n  } catch {\r\n    // Skip unreadable directories\r\n  }\r\n}\r\n\r\n/**\r\n * Builds the root TreeNode for the scan result.\r\n */\r\nasync function buildRootNode(\r\n  rootPath: string,\r\n  ruleFilesByDir: Map<string, RuleFileRecord[]>,\r\n  contextCache: Map<string, RuleContext>,\r\n  rootOnly: boolean\r\n): Promise<TreeNode> {\r\n  const rootContext = createRootContext();\r\n  const ruleFiles = ruleFilesByDir.get(rootPath) || [];\r\n  const context = deriveChildContext(rootContext, ruleFiles);\r\n  contextCache.set(rootPath, context);\r\n\r\n  // Check if root has children\r\n  let hasChildren = false;\r\n  try {\r\n    const entries = await fs.readdir(rootPath, { withFileTypes: true });\r\n    hasChildren = entries.some((e) => e.isDirectory());\r\n  } catch {\r\n    // Ignore\r\n  }\r\n\r\n  return {\r\n    path: rootPath,\r\n    name: path.basename(rootPath),\r\n    isDir: true,\r\n    state: NodeState.INCLUDED, // Root is always included\r\n    hasChildren,\r\n    modeAtPath: context.mode,\r\n  };\r\n}\r\n\r\n/**\r\n * Clear the scan cache (useful for testing).\r\n */\r\nexport function clearScanCache(): void {\r\n  scanCache.clear();\r\n}\r\n","/**\r\n * List children operation — evaluates and returns child nodes for a directory\r\n * in the preview tree.\r\n */\r\n\r\nimport fs from 'fs/promises';\r\nimport path from 'path';\r\nimport {\r\n  TreeNode,\r\n  NodeState,\r\n  RuleMode,\r\n  RuleFileRecord,\r\n  RuleContext,\r\n} from '../rules/types';\r\nimport { deriveChildContext, matchPatterns } from '../rules';\r\nimport { getCachedScan } from './index';\r\n\r\n/** Arguments for the listChildren IPC command. */\r\nexport interface ListChildrenArgs {\r\n  scanId: string;\r\n  dirPath: string;\r\n}\r\n\r\n/** Response from the listChildren IPC command. */\r\nexport interface ListChildrenResponse {\r\n  children: TreeNode[];\r\n}\r\n\r\n/**\r\n * Evaluates node state based on context and pattern matching.\r\n */\r\nfunction evaluateNodeState(\r\n  nodePath: string,\r\n  isDir: boolean,\r\n  context: RuleContext,\r\n  conflicts: string[]\r\n): NodeState {\r\n  // Check for conflict first\r\n  if (isDir && conflicts.includes(nodePath)) {\r\n    return NodeState.CONFLICT;\r\n  }\r\n\r\n  // NONE mode: everything is included\r\n  if (context.mode === RuleMode.NONE) {\r\n    return NodeState.INCLUDED;\r\n  }\r\n\r\n  // Get the rule file directory for pattern matching (use the dir of the first rule in chain)\r\n  const ruleFileDir =\r\n    context.ruleChain.length > 0\r\n      ? path.dirname(context.ruleChain[0])\r\n      : path.dirname(nodePath);\r\n\r\n  // Match against patterns\r\n  const matchResult = matchPatterns(\r\n    context.patterns,\r\n    nodePath,\r\n    isDir,\r\n    ruleFileDir\r\n  );\r\n\r\n  // IGNORE mode: matched = excluded, not matched = included\r\n  if (context.mode === RuleMode.IGNORE) {\r\n    return matchResult.matched ? NodeState.EXCLUDED : NodeState.INCLUDED;\r\n  }\r\n\r\n  // INCLUDE mode: matched = included, not matched = excluded\r\n  if (context.mode === RuleMode.INCLUDE) {\r\n    return matchResult.matched ? NodeState.INCLUDED : NodeState.EXCLUDED;\r\n  }\r\n\r\n  return NodeState.UNKNOWN;\r\n}\r\n\r\n/**\r\n * Lists and evaluates children of a directory node.\r\n */\r\nexport async function listChildren(\r\n  args: ListChildrenArgs\r\n): Promise<ListChildrenResponse> {\r\n  const { scanId, dirPath } = args;\r\n\r\n  // Retrieve cached scan\r\n  const scan = getCachedScan(scanId);\r\n  if (!scan) {\r\n    throw new Error(`Scan not found: ${scanId}`);\r\n  }\r\n\r\n  // Get parent context (should be cached)\r\n  const parentContext = scan.contextCache.get(dirPath);\r\n  if (!parentContext) {\r\n    throw new Error(`Context not found for directory: ${dirPath}`);\r\n  }\r\n\r\n  // Read directory entries\r\n  let entries: { name: string; isDir: boolean }[];\r\n  try {\r\n    const dirents = await fs.readdir(dirPath, { withFileTypes: true });\r\n    entries = dirents.map((d) => ({\r\n      name: d.name,\r\n      isDir: d.isDirectory(),\r\n    }));\r\n  } catch {\r\n    return { children: [] };\r\n  }\r\n\r\n  // Evaluate each child\r\n  const children: TreeNode[] = [];\r\n  for (const entry of entries) {\r\n    const childPath = path.join(dirPath, entry.name);\r\n    let childContext: RuleContext;\r\n\r\n    if (entry.isDir) {\r\n      // For directories, derive child context\r\n      const ruleFiles = scan.ruleFilesByDir.get(childPath) || [];\r\n      childContext = deriveChildContext(parentContext, ruleFiles);\r\n      scan.contextCache.set(childPath, childContext);\r\n    } else {\r\n      // For files, use parent context\r\n      childContext = parentContext;\r\n    }\r\n\r\n    // Evaluate state\r\n    const state = evaluateNodeState(\r\n      childPath,\r\n      entry.isDir,\r\n      childContext,\r\n      scan.conflicts\r\n    );\r\n\r\n    // Check if directory has children\r\n    let hasChildren = false;\r\n    if (entry.isDir) {\r\n      try {\r\n        const subEntries = await fs.readdir(childPath, { withFileTypes: true });\r\n        hasChildren = subEntries.some((e) => e.isDirectory());\r\n      } catch {\r\n        // Ignore\r\n      }\r\n    }\r\n\r\n    children.push({\r\n      path: childPath,\r\n      name: entry.name,\r\n      isDir: entry.isDir,\r\n      state,\r\n      hasChildren,\r\n      modeAtPath: childContext.mode,\r\n    });\r\n  }\r\n\r\n  return { children };\r\n}\r\n","/**\r\n * Explain operation — returns detailed information about why a node\r\n * is included or excluded.\r\n */\r\n\r\nimport path from 'path';\r\nimport { NodeState, RuleMode, PatternEntry } from '../rules/types';\r\nimport { matchPatterns } from '../rules';\r\nimport { getCachedScan } from './index';\r\n\r\n/** Arguments for the explain IPC command. */\r\nexport interface ExplainArgs {\r\n  scanId: string;\r\n  nodePath: string;\r\n}\r\n\r\n/** Explain data for a single node. */\r\nexport interface ExplainData {\r\n  path: string;\r\n  name: string;\r\n  decision: NodeState;\r\n  mode: RuleMode;\r\n  ruleChain: string[];\r\n  matchingPatterns: PatternEntry[];\r\n}\r\n\r\n/** Response from the explain IPC command. */\r\nexport interface ExplainResponse {\r\n  explain: ExplainData;\r\n}\r\n\r\n/**\r\n * Returns explain data for a node.\r\n */\r\nexport async function explain(args: ExplainArgs): Promise<ExplainResponse> {\r\n  const { scanId, nodePath } = args;\r\n\r\n  // Retrieve cached scan\r\n  const scan = getCachedScan(scanId);\r\n  if (!scan) {\r\n    throw new Error(`Scan not found: ${scanId}`);\r\n  }\r\n\r\n  // Get context for this node's parent directory (or the node itself if it's a directory)\r\n  const parentDir = path.dirname(nodePath);\r\n  const context = scan.contextCache.get(parentDir);\r\n  \r\n  if (!context) {\r\n    throw new Error(`Context not found for path: ${nodePath}`);\r\n  }\r\n\r\n  // Determine if this is a directory\r\n  const isDir = nodePath === scan.sourceRoot || nodePath.endsWith(path.sep);\r\n\r\n  // Determine decision\r\n  let decision: NodeState;\r\n  if (scan.conflicts.includes(nodePath)) {\r\n    decision = NodeState.CONFLICT;\r\n  } else if (context.mode === RuleMode.NONE) {\r\n    decision = NodeState.INCLUDED;\r\n  } else {\r\n    // Get the rule file directory for pattern matching\r\n    const ruleFileDir =\r\n      context.ruleChain.length > 0\r\n        ? path.dirname(context.ruleChain[0])\r\n        : parentDir;\r\n\r\n    // Match against patterns\r\n    const matchResult = matchPatterns(\r\n      context.patterns,\r\n      nodePath,\r\n      isDir,\r\n      ruleFileDir\r\n    );\r\n\r\n    if (context.mode === RuleMode.IGNORE) {\r\n      decision = matchResult.matched ? NodeState.EXCLUDED : NodeState.INCLUDED;\r\n    } else {\r\n      decision = matchResult.matched ? NodeState.INCLUDED : NodeState.EXCLUDED;\r\n    }\r\n  }\r\n\r\n  // Get matching patterns (empty if NONE mode or CONFLICT)\r\n  let matchingPatterns: PatternEntry[] = [];\r\n  if (context.mode !== RuleMode.NONE && decision !== NodeState.CONFLICT) {\r\n    const ruleFileDir =\r\n      context.ruleChain.length > 0\r\n        ? path.dirname(context.ruleChain[0])\r\n        : parentDir;\r\n\r\n    const matchResult = matchPatterns(\r\n      context.patterns,\r\n      nodePath,\r\n      isDir,\r\n      ruleFileDir\r\n    );\r\n    matchingPatterns = matchResult.matchingPatterns;\r\n  }\r\n\r\n  return {\r\n    explain: {\r\n      path: nodePath,\r\n      name: path.basename(nodePath),\r\n      decision,\r\n      mode: context.mode,\r\n      ruleChain: context.ruleChain,\r\n      matchingPatterns,\r\n    },\r\n  };\r\n}\r\n","import { ipcMain, dialog, BrowserWindow, shell, clipboard } from 'electron';\r\nimport { scan } from './scanner';\r\nimport { listChildren } from './scanner/listChildren';\r\nimport { explain } from './scanner/explain';\r\nimport { ScanArgs } from './scanner/types';\r\nimport { ListChildrenArgs } from './scanner/listChildren';\r\nimport { ExplainArgs } from './scanner/explain';\r\nimport path from 'path';\r\n\r\nexport function registerIpcHandlers(): void {\r\n  ipcMain.handle('selectFolder', async (_event, args: { kind: string }) => {\r\n    const win = BrowserWindow.getFocusedWindow();\r\n    const result = await dialog.showOpenDialog(win!, {\r\n      properties: ['openDirectory'],\r\n      title: `Select ${args.kind === 'source' ? 'Source' : 'Destination'} Folder`,\r\n    });\r\n\r\n    if (result.canceled || result.filePaths.length === 0) {\r\n      return { path: null };\r\n    }\r\n\r\n    return { path: result.filePaths[0] };\r\n  });\r\n\r\n  ipcMain.handle('scan', async (_event, args: ScanArgs) => {\r\n    return await scan(args);\r\n  });\r\n\r\n  ipcMain.handle('listChildren', async (_event, args: ListChildrenArgs) => {\r\n    return await listChildren(args);\r\n  });\r\n\r\n  ipcMain.handle('explain', async (_event, args: ExplainArgs) => {\r\n    return await explain(args);\r\n  });\r\n\r\n  ipcMain.handle('openInExplorer', async (_event, args: { dirPath: string }) => {\r\n    try {\r\n      await shell.openPath(args.dirPath);\r\n      return { success: true };\r\n    } catch (error) {\r\n      return { success: false, error: String(error) };\r\n    }\r\n  });\r\n\r\n  ipcMain.handle('copyToClipboard', async (_event, args: { text: string }) => {\r\n    try {\r\n      clipboard.writeText(args.text);\r\n      return { success: true };\r\n    } catch (error) {\r\n      return { success: false, error: String(error) };\r\n    }\r\n  });\r\n}\r\n","import { app, BrowserWindow } from 'electron';\r\nimport path from 'path';\r\nimport { registerIpcHandlers } from './ipc';\r\n\r\n// Handle creating/removing shortcuts on Windows when installing/uninstalling.\r\nif (require('electron-squirrel-startup')) {\r\n  app.quit();\r\n}\r\n\r\nlet mainWindow: BrowserWindow | null = null;\r\n\r\nconst createWindow = (): void => {\r\n  mainWindow = new BrowserWindow({\r\n    width: 1200,\r\n    height: 800,\r\n    webPreferences: {\r\n      preload: path.join(__dirname, 'preload.js'),\r\n      contextIsolation: true,\r\n      nodeIntegration: false,\r\n    },\r\n  });\r\n\r\n  // In development, load from Vite dev server\r\n  if (MAIN_WINDOW_VITE_DEV_SERVER_URL) {\r\n    mainWindow.loadURL(MAIN_WINDOW_VITE_DEV_SERVER_URL);\r\n  } else {\r\n    mainWindow.loadFile(\r\n      path.join(__dirname, `../renderer/${MAIN_WINDOW_VITE_NAME}/index.html`)\r\n    );\r\n  }\r\n};\r\n\r\napp.on('ready', () => {\r\n  registerIpcHandlers();\r\n  createWindow();\r\n});\r\n\r\napp.on('window-all-closed', () => {\r\n  app.quit();\r\n});\r\n\r\n// Vite environment declarations\r\ndeclare const MAIN_WINDOW_VITE_DEV_SERVER_URL: string | undefined;\r\ndeclare const MAIN_WINDOW_VITE_NAME: string;\r\n"],"names":["randomFillSync","randomUUID","RuleType","RuleMode","NodeState","dirName","uuidv4","scan","ipcMain","BrowserWindow","dialog","shell","clipboard","app"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}